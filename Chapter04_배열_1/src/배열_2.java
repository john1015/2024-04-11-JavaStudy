/*
 * 5개의 난수 발생 → 출력 / 평균
 * 
 * new를 이용해 메모리 할당
 * → 자동 초기화
 * int → 0
 * double → 0.0
 * long → 0L
 * float → 0.0f
 * boolean → false
 * char → '\0'
 * String → Null
 * 
 * 배열 , 클래스 
 * ----------
 * 메모리구조
 * -------------------------------------------------------------
 * 	Method Area / static
 * 	main ========> 5장
 * -------------------------------------------------------------
 * 	Stack → 지역 변수 → 관리(메모리 제체 관리)
 * 		  → {}이 종료되면 자동으로 사라짐
 * -------------------------------------------------------------
 * 	Heap → 배열의 실제값, 클래스 실제값 → 관리(프로그래머)
 * 		 → 프로그래머가 관리를 소홀시한다
 * 			---------------------- 자동 메모리 회수 (가비지 컬렉션)
 * 					| 바로 회수하지 않고 → 프로그램 종료시에 회수
 * 					| 메모리 누수 현상
 * -------------------------------------------------------------
 * 	int[] arr = new int[5]
 * 		  new → 요청한 메모리를 생성 → 생성된 위치에 주소값을 배열 변수에 넘겨준다
 * 					  주소 참조 변수 : arr=0x100
 * 		  스택					힙
 * 					 |  100  104 108 112 116 
 * 0---------------- |  ----------------------
 * 					 |	 0	| 0	| 0	| 0	| 0	|
 * 4---------------- |  |-----|---|---|---|----
 * 					 | 0x100  1   2   3   4
 * 					 | arr+0*4 arr+1*4 arr+2*4 ... →int(4byte )
 * 8---------------- | → 연속적인 메모리구조
 * 					 | arr의 첫번째 값 요청 → arr[0] → 일반 변수와 동일
 * 12--------------- | arr의 두번째 값 요청 → arr[1]
 * 					 | arr의 세번째 값 요청 → arr[2]
 * 16--------------- | ...
 * 					 | → 해당위치의 값을 인덱스로 표현 (0번부터 시작)
 * 					 | → 생성이 되면 삭제 , 추가 → 불가능(고정)
 * 					 | → 인덱스번호가 0부터 순차적으로 만들어 진다
 * 					 | 	   → 반복문 처리가 편하다
 * -------------------------------------------------------------
 * 
 * for-each
 * --------
 * int[] arr
 * for(데이터형 변수:배열명)
 * 배열에 저장된 실제 데이터값
 */

public class 배열_2 {

	public static void main(String[] args) {
		int[] arr = new int[5];
		int sum=0;
		for (int i = 0; i < 5; i++) {
			arr[i]=(int)(Math.random()*100)+1;
			System.out.print(arr[i]+" ");
			sum+=arr[i];
		}
		System.out.println();
		System.out.println("평균 : "+(double)sum/5.0);
	}

}
